{"version":3,"sources":["components/pokemonListing.tsx","components/results.tsx","components/search.tsx","services/pokemonApiService.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["PokemonListing","props","className","alt","singlePokemon","name","src","id","formatIndexNumber","types","map","item","index","key","type","onClick","onRemove","Results","pokemons","pokemon","length","Search","value","placeholder","onChange","e","currentTarget","onSubmit","fetchPokemon","a","fetch","response","json","data","output","results","populatePokemonData","Promise","all","url","App","state","searchWord","filteredPokemons","handleSearch","query","setState","getQueriedPokemons","event","preventDefault","allPokemons","searched","filter","includes","removePokemon","selectedPokemon","findIndex","currentdPokemon","splice","indexNumber","parsed","parseInt","arr","toString","split","Number","join","unshift","this","React","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c3b02389.chunk.js","sourcesContent":["import * as React from \"react\";\nimport { Pokemon } from \"../interfaces/pokemon\";\n\nexport interface PokemonListingProps {\n  singlePokemon: Pokemon;\n  onRemove: Function;\n  formatIndexNumber: Function;\n}\n\nconst imgUrl = \"https://pokeres.bastionbot.org/images/pokemon/\";\n\nconst PokemonListing: React.SFC<PokemonListingProps> = (\n  props: React.PropsWithChildren<PokemonListingProps>\n) => {\n  return (\n    <div className=\"pokemonListing\">\n      <div className=\"imageContainer\">\n        <img\n          alt={props.singlePokemon.name}\n          src={imgUrl + props.singlePokemon.id + \".png\"}\n        />\n      </div>\n      <div className=\"basicInfo\">\n        <div className=\"pokemonName\">{props.singlePokemon.name}</div>\n        <div className=\"pokemonId\">\n          #{props.formatIndexNumber(props.singlePokemon.id)}\n        </div>\n      </div>\n      <ul className=\"pokemonTypes\">\n        {props.singlePokemon.types.map((item, index) => (\n          <li key={index} className=\"pokemonSingleType\">\n            {item.type.name}\n          </li>\n        ))}\n      </ul>\n      <div className=\"columnEnd\">\n        <button\n          className=\"closeButton\"\n          onClick={() => props.onRemove(props.singlePokemon)}\n        >\n          <div className=\"circle\">\n            <div className=\"before\"></div>\n            <div className=\"after\"></div>\n          </div>\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default PokemonListing;\n","import * as React from \"react\";\nimport PokemonListing from \"./pokemonListing\";\nimport { Pokemon } from \"../interfaces/pokemon\";\n\nexport interface ResultsProps {\n  pokemons: Array<any>;\n  onRemove: Function;\n  formatIndexNumber: Function;\n}\n\nconst Results: React.SFC<ResultsProps> = (\n  props: React.PropsWithChildren<ResultsProps>\n) => {\n  return (\n    <div className=\"resultsPage\">\n      {props.pokemons.map((pokemon: Pokemon) => (\n        <PokemonListing\n          singlePokemon={pokemon}\n          key={pokemon.id}\n          onRemove={props.onRemove}\n          formatIndexNumber={props.formatIndexNumber}\n        />\n      ))}\n      {props.pokemons.length === 0 ? (\n        <div className=\"notFound\">\n          Sorry, your search did not match any Pokemon\n        </div>\n      ) : null}\n    </div>\n  );\n};\n\nexport default Results;\n","import * as React from \"react\";\n\nexport interface SearchProps {\n  value: string;\n  onChange: Function;\n  onSubmit(event: React.MouseEvent<HTMLButtonElement>): void;\n}\n\nconst Search: React.SFC<SearchProps> = (\n  props: React.PropsWithChildren<SearchProps>\n) => {\n  return (\n    <div className=\"searchBar\">\n      <div className=\"searchFormWrapper\">\n        <form>\n          <div className=\"magnifying-glass\"></div>\n          <input\n            value={props.value}\n            className=\"inputField\"\n            placeholder={\"Search by Pokedex ID\"}\n            onChange={(e) => props.onChange(e.currentTarget.value)}\n          />\n          <button className=\"searchButton\" onClick={props.onSubmit}>\n            SEARCH\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default Search;\n","const apiEndpoint = \"https://pokeapi.co/api/v2/pokemon?limit=151\";\n\ninterface PokemonApiItem {\n  name: string;\n  url: string;\n}\n\nconst fetchPokemon = async () => {\n  const response = await fetch(apiEndpoint);\n  const data = await response.json();\n\n  const output = data.results.map((pokemon: PokemonApiItem) => {\n    return populatePokemonData(pokemon);\n  });\n\n  return Promise.all(output);\n};\n\nconst populatePokemonData = async (pokemon: PokemonApiItem) => {\n  let url = pokemon.url;\n\n  const response = await fetch(url);\n  const data = await response.json();\n\n  return data;\n};\n\nexport { fetchPokemon };\n","import * as React from \"react\";\nimport \"./App.css\";\nimport Results from \"./components/results\";\nimport Search from \"./components/search\";\nimport { fetchPokemon } from \"./services/pokemonApiService\";\nimport { Pokemon } from \"./interfaces/pokemon\";\nexport interface AppState {\n  pokemons: Array<any>;\n  searchWord: string;\n  filteredPokemons: Array<any>;\n}\n\nclass App extends React.Component<any, AppState> {\n  state = { pokemons: [], searchWord: \"\", filteredPokemons: [] };\n\n  handleSearch = (query: string) => {\n    this.setState({ searchWord: query });\n  };\n\n  getQueriedPokemons = (event: React.SyntheticEvent) => {\n    event.preventDefault();\n    const { pokemons: allPokemons, searchWord } = this.state;\n\n    const searched = allPokemons.filter((pokemon: Pokemon) => {\n      // ignore esLint warning: this is a use case for loose equals operator ==\n      // eslint-disable-next-line\n      return searchWord == pokemon.id || pokemon.name.includes(searchWord);\n    });\n\n    this.setState({ filteredPokemons: searched });\n  };\n\n  removePokemon = (selectedPokemon: Pokemon) => {\n    const filteredPokemons = [...this.state.filteredPokemons];\n    const index = filteredPokemons.findIndex((currentdPokemon: Pokemon) => {\n      return currentdPokemon.id === selectedPokemon.id;\n    });\n    filteredPokemons.splice(index, 1);\n    this.setState({ filteredPokemons });\n  };\n\n  formatIndexNumber = (indexNumber: string) => {\n    let parsed = parseInt(indexNumber);\n\n    if (parsed < 10) {\n      const arr = parsed.toString(10).split(\"\").map(Number);\n      arr.splice(0, 0, 0, 0);\n      return arr.join(\"\");\n    } else if (parsed < 100) {\n      const arr = parsed.toString(10).split(\"\").map(Number);\n      arr.unshift(0);\n      return arr.join(\"\");\n    } else return parsed;\n  };\n\n  async componentDidMount() {\n    this.setState({ pokemons: await fetchPokemon() });\n    this.setState({ filteredPokemons: this.state.pokemons });\n  }\n\n  render() {\n    return (\n      <div className=\"container\">\n        <h1>Find your favorite Pokemon</h1>\n        <Search\n          value={this.state.searchWord}\n          onChange={this.handleSearch}\n          onSubmit={this.getQueriedPokemons}\n        />\n        <Results\n          pokemons={this.state.filteredPokemons}\n          onRemove={this.removePokemon}\n          formatIndexNumber={this.formatIndexNumber}\n        />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}